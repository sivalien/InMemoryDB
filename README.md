# Обоснование выбора структур данных и алгоритмов

В данном случае самый экономный по памяти способ
храненния данных - это хранение их в массиве, он не 
хранит никакой дополнительной информации только ссылки
на записи (в отличие от, например, связных списков, которые
хранят ссылку на следующий элемент).  
   
Нам нужен поиск за `O(logn)` по каждому полю записи, выполнить 
поиск за такое время в массиве можно с помощью бинарного поиска, 
если массив предварительно отсортирован. Поскольку необходим 
поиск по каждому полю, придется завести три массива, каждый 
из которых отсортирован по одному из трех полей. Считаем, что 
поле account уникально для каждой записи. А вот для полей 
`value` и `name` может быть несколько записей обладающих тем 
же значением. Если просто отсортируем два массива по этим полям, 
то поиск может занять и линейное время, поэтому в массиве 
храним пары значение поля и массив записей с таким значением 
поля. Для этого можно завести для полей `name` и `value` 
завести двумерные массивы, в каждом внутреннем массиве будут 
лежат записи с одинаковыми полями `name` или `value`, и все 
внутренние значения будут отсортированы по полю `name` или `value`. 
Поиск по полям `name` и `value` также выполняется с помощью 
бинарного поиска, и если нашли такое значение, то возвращаем 
список значений, который ему соотвествует.  
   
Операции удаления и вставки будут работать за линейное время, 
в ТЗ нет никаких ограничений на время их работы. 